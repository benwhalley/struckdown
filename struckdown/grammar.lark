// Struckdown Grammar v2.0 - XML-style syntax
// Single-stage parsing of all syntax elements

start: (block_comment | checkpoint_tag | obliviate_tag | system_tag | header_tag | user_tag | assistant_tag | include_tag | single_completion | placeholder | templatetag | markdown)*

// HTML comments (dropped from LLM prompt)
block_comment: BLOCK_COMMENT_START BLOCK_COMMENT_CONTENT? BLOCK_COMMENT_END
BLOCK_COMMENT_CONTENT: /(.|\n)+?(?=-->)/
BLOCK_COMMENT_START: "<!--"
BLOCK_COMMENT_END: "-->"

// Checkpoint tag - two styles:
// 1. <checkpoint>Name</checkpoint> - closed tag with name
// 2. <checkpoint> - auto-named (just opening tag, no closing)
checkpoint_tag: CHECKPOINT_CLOSED                          -> checkpoint_closed
              | CHECKPOINT_OPEN                            -> checkpoint_auto

CHECKPOINT_CLOSED.2: /<checkpoint\s*>(.|\n)*?<\/checkpoint>/
CHECKPOINT_OPEN.2: /<checkpoint\s*>/

// Obliviate synonym (same patterns)
obliviate_tag: OBLIVIATE_CLOSED                           -> obliviate_closed
             | OBLIVIATE_OPEN                             -> obliviate_auto

OBLIVIATE_CLOSED.2: /<obliviate\s*>(.|\n)*?<\/obliviate>/
OBLIVIATE_OPEN.2: /<obliviate\s*>/

// System tags: <system [modifiers]>content</system>
// Match opening tag with optional modifiers, parse in transformer
system_tag: SYSTEM_OPEN SYSTEM_CONTENT? SYSTEM_CLOSE

SYSTEM_OPEN.2: /<system(?:\s+(?:local|global|append|replace))*\s*>/
SYSTEM_CLOSE: "</system>"

// Header tags: <header [modifiers]>content</header>
// Same modifiers as system: local|global, append|replace
// Content is sent as user role message (appears after system message)
header_tag: HEADER_OPEN HEADER_CONTENT? HEADER_CLOSE

HEADER_OPEN.2: /<header(?:\s+(?:local|global|append|replace))*\s*>/
HEADER_CLOSE: "</header>"

// User tags: <user>content</user>
// Content is added as a separate user message (allows splitting user content)
user_tag: USER_OPEN USER_CONTENT? USER_CLOSE

USER_OPEN.2: /<user\s*>/
USER_CLOSE: "</user>"

// Assistant tags: <assistant>content</assistant>
// Content is added as a separate assistant message
assistant_tag: ASSISTANT_OPEN ASSISTANT_CONTENT? ASSISTANT_CLOSE

ASSISTANT_OPEN.2: /<assistant\s*>/
ASSISTANT_CLOSE: "</assistant>"

// Include tag: <include src="path/to/file.sd"/> or <include src='path/to/file.sd'/>
// Resolved at parse time (compile-time)
include_tag: "<include" _WHITESPACE "src=" INCLUDE_SRC _WHITESPACE? "/>"

INCLUDE_SRC: /"[^"]*"/ | /'[^']*'/

// Content terminals for tags (must match at least 1 character to avoid zero-width issues)
// Negative lookahead (?!\[\[) prevents completion slots [[...]] inside these tags
SYSTEM_CONTENT: /(?:(?!\[\[)[\s\S])+?(?=<\/system>)/
HEADER_CONTENT: /(?:(?!\[\[)[\s\S])+?(?=<\/header>)/
USER_CONTENT: /(?:(?!\[\[)[\s\S])+?(?=<\/user>)/
ASSISTANT_CONTENT: /(?:(?!\[\[)[\s\S])+?(?=<\/assistant>)/

// Markdown: everything else (with negative lookahead to exclude our syntax)
// Matches anything that's NOT our special tags, completions, or variables
// Note: <break> is now handled as [[@break|msg]] action, so not excluded here
markdown: /(?:(?!<(?:checkpoint|obliviate|system|header|user|assistant|include|!--)|{{|\[\[|{%)(?:.|\n))+/s  -> markdown_text

// Template variables: {{variable}} or {{variable.path}}
placeholder: "{{" _WHITESPACE? var_path _WHITESPACE? "}}"
var_path: CNAME ("." CNAME)*

// Jinja2 template tags: {% include 'file.sd' %}
templatetag: /{%\s.*?%}/s  -> templatetag

// Completions (unchanged from v1)
?completion: single_completion
single_completion: _OPEN_BRACKET _WHITESPACE? completion_body _WHITESPACE? _CLOSE_BRACKET

completion_body: _AT CNAME _COLON CNAME (_PIPE option_list)? -> action_call_with_var
    | _AT CNAME _COLON (_PIPE option_list)? -> action_call_auto_var
    | _AT CNAME (_PIPE option_list)? -> action_call_no_var
    | BANG? CNAME quantifier? _COLON CNAME (_PIPE option_list)? -> typed_completion_with_var
    | BANG? CNAME quantifier? _COLON (_PIPE option_list)? -> typed_completion_auto_var
    | BANG? CNAME quantifier? (_PIPE option_list)? -> typed_completion_no_var

BANG: "!"

// Underscore-prefixed terminals: filtered from tree but shown in error messages
_OPEN_BRACKET: "[["
_CLOSE_BRACKET: "]]"
_PIPE: "|"
_AT: "@"
_COLON: ":"
_WHITESPACE: /\s+/

quantifier: "*"                           -> zero_or_more
          | "+"                           -> one_or_more
          | "?"                           -> zero_or_one
          | "{" NUMBER "}"                -> exact
          | "{" NUMBER "," "}"            -> at_least
          | "{" NUMBER "," NUMBER "}"     -> between

option_list: option ("," option)*
option: STRING | /[^,\]\|]+/

%import common.CNAME
%import common.INT -> NUMBER
%import common.ESCAPED_STRING -> STRING
%import common.NEWLINE
%ignore _WHITESPACE
